"""Constants and patterns for semantic node classification."""

import re

from types import MappingProxyType

from codeweaver.semantic.categories import SemanticNodeCategory


PUNCTUATION_SYMBOLS = (",", "[", "]", "{", "}", "(", ")", ":", ";", ".", '"', "'")
"""Common punctuation/demarkation symbols across programming languages."""

OPERATOR_SYMBOLS = (
    "++=",
    "++",
    "+=",
    "+",
    "-=",
    "-",
    "*=",
    "*",
    "//=",
    "//",
    "/=",
    "/",
    "%=",
    "%",
    "**=",
    "**",
    "<<=",
    "<<",
    ">>=",
    ">>",
    "@=",
    "&&",
    "&",
    "|=",
    "|",
    "^",
    "==~",
    "=~",
    "~",
    "===",
    "!==",
    "==",
    "!=",
    "=>",
    "<=",
    "=<",
    "<",
    ">=",
    ">",
    "=",
    "!",
    "is",
    "is not",
    "in",
    "not in",
    "and",
    "or",
    "not",
)


CLASSIFICATION_PATTERNS: MappingProxyType[SemanticNodeCategory, tuple[str, ...]] = (
    MappingProxyType({
        SemanticNodeCategory.CLASS_DEFINITION: (
            r"class.*definition",
            r"struct.*definition",
            r"interface.*definition",
            r".*class",
            r".*struct",
            r".*interface",
            r"type.*definition",
        ),
        SemanticNodeCategory.TYPE_DEFINITION: (
            # Basic type patterns
            r"type.*definition",
            r"type.*alias",
            r"type.*declaration",
            r"typedef.*",
            r".*_type$",
            r"^type$",
            r"type_.*",
            r".*_simple_type$",
            r"type_specifier",
            r".*_unannotated_type$",
            r".*_declarator$",
            r".*type_annotation.*",
            r"annotated_type",
            # Comprehensive type system patterns
            r"array_type",
            r"generic_type",
            r"union_type",
            r"function_type",
            r"primary_type",
            r"constraint.*",
            r"bounded_type",
            r"optional_type",
            r"nullable_type",
            r"pointer_type",
            r"reference_type",
            r"slice_type",
            r"channel_type",
            r"map_type",
            # Language-specific type constructs
            r"tuple_type",
            r"record_type",
            r"variant_type",
            r"intersection_type",
            r"conditional_type",
            r"mapped_type",
            r"template_type",
            r"existential_type",
            r"opaque_type",
            r"associated_type",
            r"abstract_type",
            # Generic and parameterized types
            r"type_parameter.*",
            r".*type_parameter$",
            r"type_argument.*",
            r".*type_argument$",
            r"type_variable",
            r"type_bound",
            r"where_clause",
            r"type_constraint",
            # Type modifiers and qualifiers
            r"const_type",
            r"mutable_type",
            r"readonly_type",
            r"volatile_type",
            r"static_type",
            r"dynamic_type",
            # Advanced type patterns
            r"higher_kinded_type",
            r"dependent_type",
            r"refinement_type",
            r"phantom_type",
            r"newtype",
            r"type_class",
            r"trait_type",
            r"protocol_type",
            # Type expressions and operations
            r"typeof.*",
            r"keyof.*",
            r"valueof.*",
            r"infer.*",
            r"extends.*",
            r"satisfies.*",
            # Additional patterns from analysis
            r".*_declarator$",
            r".*declarator.*",
            r"specifier.*",
            r"qualifier.*",
        ),
        SemanticNodeCategory.FUNCTION_DEFINITION: (
            r"function.*definition",
            r"function.*declaration",
            r".*function",
            r"procedure.*definition",
            r"subroutine.*definition",
            r"def.*statement",
        ),
        SemanticNodeCategory.METHOD_DEFINITION: (
            r"method.*definition",
            r"method.*declaration",
            r".*method",
            r"member.*function",
            r"instance.*method",
            r"class.*method",
        ),
        SemanticNodeCategory.VARIABLE_DECLARATION: (
            r"variable.*declaration",
            r"var.*declaration",
            r"let.*declaration",
            r"const.*declaration",
            r".*variable",
            r"field.*declaration",
            r"property.*declaration",
            r".*_declaration.*",  # Abstract declarations
            r"declaration",  # Generic declaration
            # Add parameter and argument patterns
            r"parameter.*",
            r".*parameter$",
            r"formal.*",  # Formal parameters
            r"^parameter$",
            # Arguments for function calls
            r"argument(?!_list).*",  # Exclude argument_list
            # Property and field patterns
            r"property$",
            r"attribute$",
            r"field$",
        ),
        SemanticNodeCategory.IMPORT_STATEMENT: (
            r"import.*statement",
            r"import.*declaration",
            r".*import",
            r"require.*statement",
            r"use.*statement",
            r"include.*statement",
        ),
        SemanticNodeCategory.EXPORT_STATEMENT: (
            r"export.*statement",
            r"export.*declaration",
            r".*export",
            r"public.*declaration",
        ),
        SemanticNodeCategory.CONDITIONAL_STATEMENT: (
            r"if.*statement",
            r"else.*statement",
            r"elif.*statement",
            r"switch.*statement",
            r"case.*statement",
            r"conditional.*",
            # Add exact keyword matches for basic control flow
            r"^(if|else|else\sif|elif|elsif|switch|case|when)$",
            r"^(match|select)$",  # Pattern matching
            # Add block and scope patterns
            r"^block$",
            r".*_block$",
            r"chunk",
            r"scope",
        ),
        SemanticNodeCategory.LOOP_STATEMENT: (
            r"foreach.*statement",
            r"for.*statement",
            r"while.*statement",
            r"do.*while",
            r"loop.*statement",
            r".*loop",
            r"repeat.*statement",
            # Add exact keyword matches for basic loop constructs
            r"^(for|while|do|loop|repeat|foreach)$",
            r"^(until|goto)$",  # Loop control
        ),
        SemanticNodeCategory.TRY_CATCH_STATEMENT: (
            r"try.*statement",
            r"catch.*statement",
            r"except.*statement",
            r"finally.*statement",
            r".*exception.*",
        ),
        SemanticNodeCategory.RETURN_STATEMENT: (
            r"return.*statement",
            r"yield.*statement",
            r".*return",
            r".*_statement$",  # Generic statements (low priority)
            r"^statement$",  # Catch-all statement
            r".*_simple_statement$",  # Simple statements
        ),
        SemanticNodeCategory.FUNCTION_CALL: (
            r".*call.*expression",
            r"function.*call",
            r"method.*call",
            r"invocation.*",
            r".*call",
        ),
        SemanticNodeCategory.ASSIGNMENT_EXPRESSION: (
            r"assignment.*expression",
            r".*assignment",
            r"update.*expression",
        ),
        SemanticNodeCategory.PROPERTY_ACCESS: (
            r".*property.*access",
            r"field.*access",
            r"member.*access",
            r".*attribute.*access",
            r"^attribute$",
            r"^property_access$",
            r"member_expression",
            r"subscript.*",
            r"index.*expression",
        ),
        SemanticNodeCategory.BINARY_EXPRESSION: (
            r"binary.*expression",
            r"arithmetic.*expression",
            r"comparison.*expression",
            r"logical.*expression",
            r".*_expression$",  # Generic expressions (lower priority)
            r"^expression$",  # Catch-all expression
            r"primary.*expression",  # Primary expressions
        ),
        SemanticNodeCategory.LITERAL: (
            r"string.*literal",
            r"number.*literal",
            r"boolean.*literal",
            r".*literal",
            r"constant.*",
        ),
        SemanticNodeCategory.IDENTIFIER: (r"identifier", r"name", r".*id"),
        SemanticNodeCategory.COMMENT: (r"comment", r"docstring", r"documentation.*"),
        SemanticNodeCategory.ASYNC_STATEMENT: (
            r"async.*",
            r"await.*",
            r"promise.*",
            r"future.*",
            r".*async.*",
            r"concurrent.*",
            r"parallel.*",
        ),
        SemanticNodeCategory.PATTERN_MATCHING: (
            r"switch.*expression",
            r".*pattern.*",
            r"case.*pattern",
            r"match.*",
            r"destructur.*",
            r"pattern_.*",
            r".*_pattern$",
            r"guard.*",
            r"when.*",
            r"case_clause",
            r"match_.*",
        ),
        SemanticNodeCategory.OPERATOR: (
            r".*operator.*",
            r"binary_operator",
            r"unary_operator",
            r"boolean_operator",
            r"comparison_operator",
            r"arithmetic_operator",
            r"logical_operator",
            r"bitwise.*",
            r"increment.*",
            r"decrement.*",
            re.escape("|".join(OPERATOR_SYMBOLS)),
        ),
        SemanticNodeCategory.MARKUP_ELEMENT: (
            r".*element.*",
            r".*tag.*",
            r"start_tag",
            r"end_tag",
            r"self_closing_tag",
            r"style_element",
            r"script_element",
            r"doctype",
            r"attribute_.*",
            r".*_tag$",
        ),
        SemanticNodeCategory.PREPROCESSOR: (
            r"pragma.*",
            r"directive.*",
            r"macro.*",
            r"include.*",
            r"define.*",
            r"ifdef.*",
            r"ifndef.*",
            r"preproc.*",
        ),
        SemanticNodeCategory.ANNOTATION: (
            r".*annotation.*",
            r"decorator.*",
            r"attribute.*",
            r"metadata.*",
            r"^decorator$",
            r"^annotation$",
            r"^attribute$",
            r"modifier.*",
            r".*_modifier$",
            r"access_.*",
            r"visibility.*",
            r"qualifier.*",
            r"specifier.*",
        ),
        SemanticNodeCategory.PUNCTUATION: (
            r".*punctuation",
            r".*delimiter",
            r".*bracket",
            r".*paren",
            r".*brace",
            r"semicolon",
            r"comma",
            # character punctuation symbols
            re.escape("|".join(PUNCTUATION_SYMBOLS)),
            # Structural list patterns
            r"argument_list$",
            r"arguments$",
            r"expression_list$",
            r".*_list$",  # General list patterns
            r"^array$",  # Simple array containers
            r"^list$",  # Simple list containers
            r"separator.*",
            r".*_separator$",
            r"terminator.*",
            r".*_terminator$",
            r"^dot$",
            r"^bang$",
            r"^pipe$",
        ),
    })
)
